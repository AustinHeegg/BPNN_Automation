import torch
import torch.nn as nn
from sklearn.metrics import mean_squared_error, r2_score
from torch import optim


class BPNN(nn.Module):
    def __init__(self, input_size, hidden_size, hidden_layer, output_size):
        super(BPNN, self).__init__()
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.hidden_layer = hidden_layer
        self.output_size = output_size
        self.fcs = nn.ModuleList()

        self.fcs.append(nn.Linear(input_size, hidden_size))
        for _ in range(hidden_layer - 1):
            self.fcs.append(nn.Linear(hidden_size, hidden_size))
        self.fc_out = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        for i in range(self.hidden_layer):
            x = torch.sigmoid(self.fcs[i](x))
        x = self.fc_out(x)
        return x

    @staticmethod
    def initialize_model(input_size, hidden_size, output_size, hidden_layers, learning_rate):
        model = BPNN(input_size, hidden_size, output_size, hidden_layers)
        criterion = nn.MSELoss()
        optimizer = optim.SGD(model.parameters(), lr=learning_rate)
        return model, criterion, optimizer

    @staticmethod
    def train(model, train_loader, criterion, optimizer, num_epochs, full_scale):
        losses = []
        for epoch in range(num_epochs):
            epoch_loss = 0
            for batch_idx, (inputs, targets) in enumerate(train_loader):
                # 前向传播
                outputs = model(inputs)
                loss = criterion(outputs, targets)

                # 反向传播和优化
                optimizer.zero_grad()
                loss.backward()
                optimizer.step()

                epoch_loss += loss.item()

                # 每处理一个batch后打印状态
                if (batch_idx + 1) % 100 == 0:  # 每100个batch打印一次
                    print(
                        f'Epoch {epoch + 1}/{num_epochs}, Batch {batch_idx + 1}/{len(train_loader)}, Loss: {loss.item():.4f}')

            # 计算并记录平均损失
            epoch_loss /= len(train_loader)
            losses.append(epoch_loss)
            # 计算相对精度
            relative_accuracy = 1 - (epoch_loss / full_scale)

            if (epoch + 1) % 1000 == 0:
                print(
                    f'Epoch [{epoch + 1}/{num_epochs}], Loss: {epoch_loss:.4f}, '
                    f'Relative Accuracy: {relative_accuracy:.4f}')

        return losses

    @staticmethod
    def test(model, X_test, y_test):
        model.eval()  # 将模型设置为评估模式
        with torch.no_grad():
            predictions = model(X_test)

            # 将张量转换为 NumPy 数组
            predictions_np = predictions.numpy()
            y_test_np = y_test.numpy()

            # 计算评估指标
            mse = mean_squared_error(y_test_np, predictions_np)
            r2 = r2_score(y_test_np, predictions_np)

            print("Performance Metrics:")
            print(f"Mean Squared Error (MSE): {mse:.4f}")
            print(f"R-squared Score: {r2:.4f}")
